[Concurrency](https://medium.com/better-programming/javascript-internals-under-the-hood-of-a-browser-f357378cc922)
Right after the setTimeout function is executed — the browser engine places setTimeout’s callback function into an event table. It’s a data structure which maps registered callbacks to events, in our case onTimeout function to timeout event.
Once the timer expires, in our case immediately as we put 0 ms as the delay, the event is fired and the onTimeout function is put in the event queue (aka the callback queue or message queue or task queue). The event queue is a data structure which consists of callback functions (tasks) to be processed in the future. And last but not least, the event loop, a constantly running loop, checks whether Call Stack is empty. If so the first added callback from the event queue is executed, hence moved to the call stack. The processing of functions continues until the call stack is once again empty. Then the event loop will process the next callback in the event queue (if there is one). ECMAScript 2015 introduced the concept of the job queue (aka Micro-task queue). This queue is filled with Promise resolve and reject functions. Callbacks in the job queue have a higher priority of execution than callbacks in the event queue. Which means that the event loop will execute all of them one by one before any other callback in the event queue.